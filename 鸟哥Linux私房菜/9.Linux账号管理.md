## 9.1账号与群组

### 9.1.1 使用者识别码 UID与GID

```bash
# 1\. 先察看一下，系统里面有没有一个名为 dmtsai 的用户？
[root@study ~]# id dmtsai
uid=1000（dmtsai） gid=1000（dmtsai） groups=1000（dmtsai）,10（wheel） <==确定有这个帐号喔！
[root@study ~]# ll -d /home/dmtsai
drwx------. 17 dmtsai dmtsai 4096 Jul 17 19:51 /home/dmtsai
# 瞧一瞧，使用者的字段正是 dmtsai 本身喔！
# 2\. 修改一下，将刚刚我们的 dmtsai 的 1000 UID 改为 2000 看看：
[root@study ~]# vim /etc/passwd
....（前面省略）....
dmtsai:x:2000:1000:dmtsai:/home/dmtsai:/bin/bash <==修改一下特殊字体部分，由 1000 改过来
[root@study ~]# ll -d /home/dmtsai
drwx------. 17 1000 dmtsai 4096 Jul 17 19:51 /home/dmtsai
# 很害怕吧！怎么变成 1000 了？因为文件只会记录 UID 的数字而已！
# 因为我们乱改，所以导致 1000 找不到对应的帐号，因此显示数字！
# 3\. 记得将刚刚的 2000 改回来！
[root@study ~]# vim /etc/passwd
....（前面省略）....
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash <==“务必一定要”改回来！
```

### 9.1.2 使用者账号

Linux 系统上面的使用者如果需要登陆主机以取得 shell 的环境来工作时，他需要如何进行
呢？ 首先，他必须要在计算机前面利用 tty1~tty6 的终端机提供的 login 接口，并输入帐号与密码后才能够登陆。 如果是通过网络的话，那至少使用者就得要学习 ssh 这个功能了 （服务器篇再来谈）。 那么你输入帐号密码后，系统帮你处理了什么呢？

- 先找寻 /etc/passwd 里面是否有你输入的帐号？如果没有则跳出，如果有的话则将该帐号对应的 UID 与 GID （在 /etc/group 中） 读出来，另外，该帐号的主文件夹与 shell 设置也一并读出；

- 再来则是核对密码表啦！这时 Linux 会进入 /etc/shadow 里面找出对应的帐号与 UID，然后核对一下你刚刚输入的密码与里头的密码是否相符？

- 如果一切都 OK 的话，就进入 Shell 控管的阶段啰！

下面我们简单列出账号内容

```bash
xiaoyou@dev:~$ head -n 4 /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
```

可以明显的看出来，每一行使用“:”分隔开，共有七个咚咚，分别是：

1. 帐号名称： 就是帐号啦！用来提供给对数字不太敏感的人类使用来登陆系统的！需要用来对应 UID 喔。例如 root 的 UID 对应就是 0 （第三字段）；

2. 密码： 早期 Unix 系统的密码就是放在这字段上！但是因为这个文件的特性是所有的程序都能够读取，这样一来很容易造成密码数据被窃取， 因此后来就将这个字段的密码数据给他改放到 /etc/shadow 中了。所以这里你会看到一个“ x ”，呵呵！

3. UID： 这个就是使用者识别码啰！通常 Linux 对于 UID 有几个限制需要说给您了解一
   下：

```bash
| id 范围 | 该 ID 使用者特性 |
| 0（系统管理员） | 当 UID 是 0 时，代表这个帐号是“系统管理员”！ 所以当你要让其他的帐号名称也具有 root 的权限时，将该帐号的 UID 改为 0 即可。 这也就是说，一部系统上面的系统管理员不见得只有 root 喔！ 不过，很不建议有多个帐号的 UID 是 0 啦～容易让系统管理员混乱！ |
| 1~999（系统帐号） | 保留给系统使用的 ID，其实除了 0 之外，其他的 UID 权限与特性并没有不一样。默认 1000 以下的数字让给系统作为保留帐号只是一个习惯。由于系统上面启动的网络服务或背景服务希望使用较小的权限去运行，因此不希望使用 root 的身份去执行这些服务， 所以我们就得要提供这些运行中程序的拥有者帐号才行。这些系统帐号通常是不可登陆的， 所以才会有我们在[第十章](../Text/index.html)提到的 /sbin/nologin 这个特殊的 shell 存在。根据系统帐号的由来，通常这类帐号又约略被区分为两种：1~200：由 distributions 自行创建的系统帐号；201~999：若使用者有系统帐号需求时，可以使用的帐号 UID。 |
| 1000~60000（可登陆帐号） | 给一般使用者用的。事实上，目前的 linux 核心 （3.10.x 版）已经可以支持到 429496
```

4. GID： 这个与 /etc/group 有关！其实 /etc/group 的观念与 /etc/passwd 差不多，只是他是用来规范群组名称与 GID 的对应而已！

5. 使用者信息说明栏： 这个字段基本上并没有什么重要用途，只是用来解释这个帐号的意
   义而已！不过，如果您提供使用 finger 的功能时， 这个字段可以提供很多的讯息呢！本
   章后面的 chfn 指令会来解释这里的说明。

6. 主文件夹： 这是使用者的主文件夹，以上面为例， root 的主文件夹在 /root ，所以当
   root 登陆之后，就会立刻跑到 /root 目录里头啦！呵呵！ 如果你有个帐号的使用空间特别的大，你想要将该帐号的主文件夹移动到其他的硬盘去该怎么作？ 没有错！可以在这个字段进行修改呦！默认的使用者主文件夹在 /home/yourIDnam

7. Shell： 我们在第十章 BASH 提到很多次，当使用者登陆系统后就会取得一个 Shell 来与
   系统的核心沟通以进行使用者的操作任务。那为何默认 shell 会使用 bash 呢？就是在这
   个字段指定的啰！ 这里比较需要注意的是，有一个 shell 可以用来替代成让帐号无法取得shell 环境的登陆动作！那就是 /sbin/nologin 这个东西！这也可以用来制作纯 pop 邮件帐号者的数据呢！

下面来看/etc/shadow

```bash
[root@study ~]# head -n 4 /etc/shadow
root:$6$wtbCCce/PxMeE5wm$KE2IfSJr.YLP7Rcai6oa/T7KFhO...:16559:0:99999:7::: <==下面说明用
bin:*:16372:0:99999:7:::
daemon:*:16372:0:99999:7:::
adm:*:16372:0:99999:7:::
```

基本上， shadow 同样以“:”作为分隔符号，如果数一数，会发现共有九个字段啊，这九个字段的用途是这样的：

1. 帐号名称： 由于密码也需要与帐号对应啊～因此，这个文件的第一栏就是帐号，必须要
   与 /etc/passwd 相同才行！

2. 密码： 这个字段内的数据才是真正的密码，而且是经过编码的密码 （加密） 啦！ 你只
   会看到有一些特殊符号的字母就是了！需要特别留意的是，虽然这些加密过的密码很难
   被解出来， 但是“很难”不等于“不会”，所以，这个文件的默认权限是“-rw-------”或者是“----
   ------”，亦即只有 root 才可以读写就是了！你得随时注意，不要不小心更动了这个文件的权限呢！

> 另外，由于各种密码编码的技术不一样，因此不同的编码系统会造成这个字段的长度不相同。 举例来说，旧式的 DES, MD5 编码系统产生的密码长度就与目前惯用的 SHA 不同[2]！SHA 的密码长度明显的比较长些。由于固定的编码系统产生的密码长度必须一致，因此“当你让这个字段的长度改变后，该密码就会失效（算不出来）”。 很多软件通过这个功能，在此字段前加上 ! 或 * 改变密码字段长度，就会让密码“暂时失效”了。

3. 最近更动密码的日期： 这个字段记录了“更动密码那一天”的日期，不过，很奇怪呀！在
   我的例子中怎么会是 16559 呢？呵呵，这个是因为计算 Linux 日期的时间是以 1970 年 1月 1 日作为 1 而累加的日期，1971 年 1 月 1 日则为 366 啦！ 得注意一下这个数据呦！上述的 16559 指的就是 2015-05-04 那一天啦！了解乎？ 而想要了解该日期可以使用本章后面 chage 指令的帮忙！至于想要知道某个日期的累积日数， 可使用如下的程序计算：

```bash
[root@study ~]# echo $（（$（date --date="2015/05/04" +%s）/86400+1））
16559
```

4. 密码不可被更动的天数：（与第 3 字段相比） 第四个字段记录了：这个帐号的密码在最
   近一次被更改后需要经过几天才可以再被变更！如果是 0 的话， 表示密码随时可以更动
   的意思。这的限制是为了怕密码被某些人一改再改而设计的！如果设置为 20 天的话，那
   么当你设置了密码之后， 20 天之内都无法改变这个密码呦！

5. 密码需要重新变更的天数：（与第 3 字段相比） 经常变更密码是个好习惯！为了强制要
   求使用者变更密码，这个字段可以指定在最近一次更改密码后， 在多少天数内需要再次
   的变更密码才行。你必须要在这个天数内重新设置你的密码，否则这个帐号的密码将
   会“变为过期特性”。 而如果像上面的 99999 （计算为 273 年） 的话，那就表示，呵呵，密码的变更没有强制性之意。

6. 密码需要变更期限前的警告天数：（与第 5 字段相比） 当帐号的密码有效期限快要到的
   时候 （第 5 字段），系统会依据这个字段的设置，发出“警告”言论给这个帐号，提醒
   他“再过 n 天你的密码就要过期了，请尽快重新设置你的密码呦！”，如上面的例子，则是密码到期之前的 7 天之内，系统会警告该用户。

7. 密码过期后的帐号宽限时间（密码失效日）：（与第 5 字段相比） 密码有效日期为“更新
   日期（第3字段）”+“重新变更日期（第5字段）”，过了该期限后使用者依旧没有更新密
   码，那该密码就算过期了。 虽然密码过期但是该帐号还是可以用来进行其他工作的，包
   括登陆系统取得 bash 。不过如果密码过期了， 那当你登陆系统时，系统会强制要求你
   必须要重新设置密码才能登陆继续使用喔，这就是密码过期特性。
   那这个字段的功能是什么呢？是在密码过期几天后，如果使用者还是没有登陆更改密
   码，那么这个帐号的密码将会“失效”， 亦即该帐号再也无法使用该密码登陆了。要注意
   密码过期与密码失效并不相同。

8. 帐号失效日期： 这个日期跟第三个字段一样，都是使用 1970 年以来的总日数设置。这
   个字段表示： 这个帐号在此字段规定的日期之后，将无法再使用。 就是所谓的“帐号失
   效”，此时不论你的密码是否有过期，这个“帐号”都不能再被使用！ 这个字段会被使用通
   常应该是在“收费服务”的系统中，你可以规定一个日期让该帐号不能再使用啦！

9. 保留： 最后一个字段是保留的，看以后有没有新功能加入。

### 9.1.3 关于群组

下面介绍 /etc/group 与 /etc/gshadow

/etc/group 文件结构

这个文件就是在记录 GID 与群组名称的对应了～

```bash
xiaoyou@dev:~$ head -n 4 /etc/group
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
```

这个文件每一行代表一个群组，也是以冒号“:”作为字段的分隔符号，共分为四栏，每一字段
的意义是：

1. 群组名称： 就是群组名称啦！同样用来给人类使用的，基本上需要与第三字段的 GID 对
   应。

2. 群组密码： 通常不需要设置，这个设置通常是给“群组管理员”使用的，目前很少有这个
   机会设置群组管理员啦！ 同样的，密码已经移动到 /etc/gshadow 去，因此这个字段只会存在一个“x”而已；

3. GID： 就是群组的 ID 啊。我们 /etc/passwd 第四个字段使用的 GID 对应的群组名，就是由这里对应出来的！

4. 此群组支持的帐号名称： 我们知道一个帐号可以加入多个群组，那某个帐号想要加入此
   群组时，将该帐号填入这个字段即可。 举例来说，如果我想要让 dmtsai 与 alex 也加入
   root 这个群组，那么在第一行的最后面加上“dmtsai,alex”，注意不要有空格， 使成为“
   root: x: 0:dmtsai,alex ”就可以啰～

这几个字段的关系如下

![](../images/2022-11-08-21-34-35-image.png)

有效群组（effective group）与初始群组（initial group）

还记得每个使用者在他的 /etc/passwd 里面的第四栏有所谓的 GID 吧？那个 GID 就是所谓
的“初始群组 （initial group） ”！也就是说，当使用者一登陆系统，立刻就拥有这个群组的相关权限的意思。 举例来说，我们上面提到 dmtsai 这个使用者的 /etc/passwd 与 /etc/group 还有 /etc/gshadow 相关的内容如下：

```bash
[root@study ~]# usermod -a -G users dmtsai <==先设置好次要群组
[root@study ~]# grep dmtsai /etc/passwd /etc/group /etc/gshadow
/etc/passwd:dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
/etc/group:wheel:x:10:dmtsai <==次要群组的设置、安装时指定的
/etc/group:users:x:100:dmtsai <==次要群组的设置
/etc/group:dmtsai:x:1000: <==因为是初始群组，所以第四字段不需要填入帐号
/etc/gshadow:wheel:::dmtsai <==次要群组的设置
/etc/gshadow:users:::dmtsai <==次要群组的设置
/etc/gshadow:dmtsai:!!::
```

groups: 有效与支持群组的观察

如果我以 dmtsai 这个使用者的身份登陆后，该如何知道我所有支持的群组呢？ 很简单啊，直接输入 groups 就可以了！注意喔，是 groups 有加 s 呢！结果像这样：

```bash
[dmtsai@study ~]$ groups
dmtsai wheel users
```

第一个输出的群组即为有效群组 （effective group） 了。 也就是说，我的有效群
组为 dmtsai 啦～此时，如果我以 touch 去创建一个新文件，例如： “ touch test ”，那么这个文件的拥有者为 dmtsai ，而且群组也是 dmtsai 的啦。

通常有效群组的作用是在新建文件啦！

newgrp: 有效群组的切换

使用 newgrp 是有限制的，那就是你想要
切换的群组必须是你已经有支持的群组。举例来说， dmtsai 可以在 dmtsai/wheel/users 这三个群组间切换有效群组，但是 dmtsai 无法切换有效群组成为 sshd 啦！使用的方式如下：

```bash
[dmtsai@study ~]$ newgrp users
[dmtsai@study ~]$ groups
users wheel dmtsai
[dmtsai@study ~]$ touch test2
[dmtsai@study ~]$ ll test*
-rw-rw-r--. 1 dmtsai dmtsai 0 Jul 20 19:54 test
-rw-r--r--. 1 dmtsai users 0 Jul 20 19:56 test2
[dmtsai@study ~]$ exit # 注意！记得离开 newgrp 的环境喔！
```

那么如何让一个帐号加入不同的群组就是问题的所在啰。你要加入一个群组有两个方式，一个是通过系统管理员 （root） 利用 usermod 帮你加入，如果 root 太忙了而且你的系统有设置群组管理员，那么你可以通过群组管理员以 gpasswd 帮你加入他所管理的群组中！

/etc/gshadow

```bash
[root@study ~]# head -n 4 /etc/gshadow
root:::
bin:::
daemon:::
sys:::
```

这个文件内同样还是使用冒号“:”来作为字段的分隔字符，而且你会发现，这个文件几乎与
/etc/group 一模一样啊！是这样没错～不过，要注意的大概就是第二个字段吧～第二个字段是密码栏， 如果密码栏上面是“!”或空的时，表示该群组不具有群组管理员！至于第四个字段也就是支持的帐号名称啰～ 这四个字段的意义为：

1.  群组名称

2. 密码栏，同样的，开头为 ! 表示无合法密码，所以无群组管理员

3. 群组管理员的帐号 （相关信息在 gpasswd 中介绍）

4. 有加入该群组支持的所属帐号 （与 /etc/group 内容相同！）

## 9.2 账号管理

### 9.2.1 新增与移除使用者

要如何在 Linux 的系统新增一个使用者啊？呵呵～真是太简单了～我们登陆系统时会输入
（1）帐号与 （2）密码， 所以创建一个可用的帐号同样的也需要这两个数据。那帐号可以使用 useradd 来新建使用者，密码的给予则使用 passwd 这个指令！这两个指令下达方法如
下：

```bash
[root@study ~]# useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\
&gt; [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 使用者帐号名
选项与参数：
-u ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个帐号；
-g ：后面接的那个群组名称就是我们上面提到的 initial group 啦～
该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。
-G ：后面接的群组名称则是这个帐号还可以加入的群组。
这个选项与参数会修改 /etc/group 内的相关数据喔！
-M ：强制！不要创建使用者主文件夹！（系统帐号默认值）
-m ：强制！要创建使用者主文件夹！（一般帐号默认值）
-c ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设置的啦～
-d ：指定某个目录成为主文件夹，而不要使用默认值。务必使用绝对路径！
-r ：创建一个系统的帐号，这个帐号的 UID 会有限制 （参考 /etc/login.defs）
-s ：后面接一个 shell ，若没有指定则默认是 /bin/bash 的啦～
-e ：后面接一个日期，格式为“YYYY-MM-DD”此项目可写入 shadow 第八字段，
亦即帐号失效日的设置项目啰；
-f ：后面接 shadow 的第七字段项目，指定密码是否会失效。0为立刻失效，
-1 为永远不失效（密码只会过期而强制于登陆时重新设置而已。）
范例一：完全参考默认值创建一个使用者，名称为 vbird1
[root@study ~]# useradd vbird1
[root@study ~]# ll -d /home/vbird1
drwx------. 3 vbird1 vbird1 74 Jul 20 21:50 /home/vbird1
# 默认会创建使用者主文件夹，且权限为 700 ！这是重点！
[root@study ~]# grep vbird1 /etc/passwd /etc/shadow /etc/group
/etc/passwd:vbird1:x:1003:1004::/home/vbird1:/bin/bash
/etc/shadow:vbird1:!!:16636:0:99999:7:::
/etc/group:vbird1:x:1004: &lt;==默认会创建一个与帐号一模一样的群组名
```

如果有一些特殊要求

```bash
范例二：假设我已知道我的系统当中有个群组名称为 users ，且 UID 1500 并不存在，
请用 users 为初始群组，以及 uid 为 1500 来创建一个名为 vbird2 的帐号
[root@study ~]# useradd -u 1500 -g users vbird2
[root@study ~]# ll -d /home/vbird2
drwx------. 3 vbird2 users 74 Jul 20 21:52 /home/vbird2
[root@study ~]# grep vbird2 /etc/passwd /etc/shadow /etc/group
/etc/passwd:vbird2:x:1500:100::/home/vbird2:/bin/bash
/etc/shadow:vbird2:!!:16636:0:99999:7:::
# 看一下，UID 与 initial group 确实改变成我们需要的了！
```

下面我们创建一个系统账号

```bash
范例三：创建一个系统帐号，名称为 vbird3
[root@study ~]# useradd -r vbird3
[root@study ~]# ll -d /home/vbird3
ls: cannot access /home/vbird3: No such file or directorya &lt;==不会主动创建主文件夹
[root@study ~]# grep vbird3 /etc/passwd /etc/shadow /etc/group
/etc/passwd:vbird3:x:699:699::/home/vbird3:/bin/bash
/etc/shadow:vbird3:!!:16636::::::
/etc/group:vbird3:x:699:
```

其实 useradd 的默认值可以使用下面的方法调用出来：

```bash
[root@study ~]# useradd -D
GROUP=100 &lt;==默认的群组
HOME=/home &lt;==默认的主文件夹所在目录
INACTIVE=-1 &lt;==密码失效日，在 shadow 内的第 7 栏
EXPIRE= &lt;==帐号失效日，在 shadow 内的第 8 栏
SHELL=/bin/bash &lt;==默认的 shell
SKEL=/etc/skel &lt;==使用者主文件夹的内容数据参考目录
CREATE_MAIL_SPOOL=yes &lt;==是否主动帮使用者创建邮件信箱（mailbox）
```

除了这些基本的帐号设置值之外， UID/GID 还有密码参数又是在哪里参考的呢？那就得要看
一下 /etc/login.defs 啦！ 这个文件的内容有点像下面这样：

```bash
MAIL_DIR /var/spool/mail &lt;==使用者默认邮件信箱放置目录
PASS_MAX_DAYS 99999 &lt;==/etc/shadow 内的第 5 栏，多久需变更密码日数
PASS_MIN_DAYS 0 &lt;==/etc/shadow 内的第 4 栏，多久不可重新设置密码日数
PASS_MIN_LEN 5 &lt;==密码最短的字符长度，已被 pam 模块取代，失去效用！
PASS_WARN_AGE 7 &lt;==/etc/shadow 内的第 6 栏，过期前会警告的日数
UID_MIN 1000 &lt;==使用者最小的 UID，意即小于 1000 的 UID 为系统保留
UID_MAX 60000 &lt;==使用者能够用的最大 UID
SYS_UID_MIN 201 &lt;==保留给使用者自行设置的系统帐号最小值 UID
SYS_UID_MAX 999 &lt;==保留给使用者自行设置的系统帐号最大值 UID
GID_MIN 1000 &lt;==使用者自订群组的最小 GID，小于 1000 为系统保留
GID_MAX 60000 &lt;==使用者自订群组的最大 GID
SYS_GID_MIN 201 &lt;==保留给使用者自行设置的系统帐号最小值 GID
SYS_GID_MAX 999 &lt;==保留给使用者自行设置的系统帐号最大值 GID
CREATE_HOME yes &lt;==在不加 -M 及 -m 时，是否主动创建使用者主文件夹？
UMASK 077 &lt;==使用者主文件夹创建的 umask ，因此权限会是 700
USERGROUPS_ENAB yes &lt;==使用 userdel 删除时，是否会删除初始群组
ENCRYPT_METHOD SHA512 &lt;==密码加密的机制使用的是 sha512 这一个机制！
```

创建好账号后，下面我们来处理密码

```bash
[root@study ~]# passwd [--stdin] [帐号名称] &lt;==所有人均可使用来改自己的密码
[root@study ~]# passwd [-l] [-u] [--stdin] [-S] \
&gt; [-n 日数] [-x 日数] [-w 日数] [-i 日期] 帐号 &lt;==root 功能
选项与参数：
--stdin ：可以通过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！
-l ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效；
-u ：与 -l 相对，是 Unlock 的意思！
-S ：列出密码相关参数，亦即 shadow 文件内的大部分信息。
-n ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数
-x ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码
-w ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数
-i ：后面接“日期”，shadow 的第 7 字段，密码失效日期
范例一：请 root 给予 vbird2 密码
[root@study ~]# passwd vbird2
Changing password for user vbird2.
New UNIX password: &lt;==这里直接输入新的密码，屏幕不会有任何反应
BAD PASSWORD: The password is shorter than 8 characters &lt;==密码太简单或过短的错误！
Retype new UNIX password: &lt;==再输入一次同样的密码
passwd: all authentication tokens updated successfully. &lt;==竟然还是成功修改了！
```

那如果是使用者自己要改密码呢？ 包括 root 也是这样修改的喔！

```bash
范例二：用 vbird2 登陆后，修改 vbird2 自己的密码
[vbird2@study ~]$ passwd &lt;==后面没有加帐号，就是改自己的密码！
Changing password for user vbird2.
Changing password for vbird2
（current） UNIX password: &lt;==这里输入“原有的旧密码”
New UNIX password: &lt;==这里输入新密码
BAD PASSWORD: The password is shorter than 8 characters &lt;==密码太短！不可以设置！重新想
New password: &lt;==这里输入新想的密码
BAD PASSWORD: The password fails the dictionary check - it is based on a dictionary word
# 同样的，密码设置在字典里面找的到该字串，所以也是不建议！无法通过，再想新的！
New UNIX password: &lt;==这里再想个新的密码来输入吧
Retype new UNIX password: &lt;==通过密码验证！所以重复这个密码的输入
passwd: all authentication tokens updated successfully. &lt;==有无成功看关键字
```

为了方便系统管理，新版的 passwd 还加入了很多创意选项喔！鸟哥个人认为最好用的大概
就是这个“ --stdin ”了！ 举例来说，你想要帮 vbird2 变更密码成为 abc543CC ，可以这样下达指令呢！

```bash
范例三：使用 standard input 创建用户的密码
[root@study ~]# echo "abc543CC" &#124; passwd --stdin vbird2
Changing password for user vbird2.
passwd: all authentication tokens updated successfully.
```

这个动作会直接更新使用者的密码而不用再次的手动输入！好处是方便处理，缺点是这个密
码会保留在指令中， 未来若系统被攻破，人家可以在 /root/.bash_history 找到这个密码呢！
所以这个动作通常仅用在 shell script 的大量创建使用者帐号当中！要注意的是，这个选项并
不存在所有 distributions 版本中

如果你想要让 vbird2 的密码具有相当的规则，举例来说你要让 vbird2 每 60 天需要变更密
码， 密码过期后 10 天未使用就宣告帐号失效，那该如何处理？

```bash
范例四：管理 vbird2 的密码使具有 60 天变更、密码过期 10 天后帐号失效的设置
[root@study ~]# passwd -S vbird2
vbird2 PS 2015-07-20 0 99999 7 -1 （Password set, SHA512 crypt.）
# 上面说明密码创建时间 （2015-07-20）、0 最小天数、99999 变更天数、7 警告日数与密码不会失效 （-1）
[root@study ~]# passwd -x 60 -i 10 vbird2
[root@study ~]# passwd -S vbird2
vbird2 PS 2015-07-20 0 60 7 10 （Password set, SHA512 crypt.）
```

那如果我想要让某个帐号暂时无法使用密码登陆主机呢？举例来说， vbird2 这家伙最近老是
胡乱在主机乱来， 所以我想要暂时让她无法登陆的话，最简单的方法就是让她的密码变成不
合法 （shadow 第 2 字段长度变掉）！ 处理的方法就更简单的！

```bash
范例五：让 vbird2 的帐号失效，观察完毕后再让她失效
[root@study ~]# passwd -l vbird2
[root@study ~]# passwd -S vbird2
vbird2 LK 2015-07-20 0 60 7 10 （Password locked.）
# 嘿嘿！状态变成“ LK, Lock ”了啦！无法登陆喔！
[root@study ~]# grep vbird2 /etc/shadow
vbird2:!!$6$iWWO6T46$uYStdkB7QjcUpJaCLB.OOp...:16636:0:60:7:10::
# 其实只是在这里加上 !! 而已！
[root@study ~]# passwd -u vbird2
[root@study ~]# grep vbird2 /etc/shadow
vbird2:$6$iWWO6T46$uYStdkB7QjcUpJaCLB.OOp...:16636:0:60:7:10::
# 密码字段恢复正常！
```

除了使用 passwd -S 之外，有没有更详细的密码参数显示功能呢？有的！那就是 chage 了！
他的用法如下：

```bash
[root@study ~]# chage [-ldEImMW] 帐号名
选项与参数：
-l ：列出该帐号的详细密码参数；
-d ：后面接日期，修改 shadow 第三字段（最近一次更改密码的日期），格式 YYYY-MM-DD
-E ：后面接日期，修改 shadow 第八字段（帐号失效日），格式 YYYY-MM-DD
-I ：后面接天数，修改 shadow 第七字段（密码失效日期）
-m ：后面接天数，修改 shadow 第四字段（密码最短保留天数）
-M ：后面接天数，修改 shadow 第五字段（密码多久需要进行变更）
-W ：后面接天数，修改 shadow 第六字段（密码过期前警告日期）
范例一：列出 vbird2 的详细密码参数
[root@study ~]# chage -l vbird2
Last password change : Jul 20, 2015
Password expires : Sep 18, 2015
Password inactive : Sep 28, 2015
Account expires : never
Minimum number of days between password change : 0
Maximum number of days between password change : 60
Number of days of warning before password expires : 7
```

chage 有一个功能很不错喔！如果你想要让“使用者在第一次登陆时， 强制她们一定要更改密
码后才能够使用系统资源”，可以利用如下的方法来处理的！

```bash
范例二：创建一个名为 agetest 的帐号，该帐号第一次登陆后使用默认密码，但必须要更改过密码后，
使用新密码才能够登陆系统使用 bash 环境
[root@study ~]# useradd agetest
[root@study ~]# echo "agetest" &#124; passwd --stdin agetest
[root@study ~]# chage -d 0 agetest
[root@study ~]# chage -l agetest &#124; head -n 3
Last password change : password must be changed
Password expires : password must be changed
Password inactive : password must be changed
# 此时此帐号的密码创建时间会被改为 1970/1/1 ，所以会有问题！
范例三：尝试以 agetest 登陆的情况
You are required to change your password immediately （root enforced）
WARNING: Your password has expired.
You must change your password now and login again!
Changing password for user agetest.
Changing password for agetest
（current） UNIX password: &lt;==这个帐号被强制要求必须要改密码！
```

下面简单介绍一下如何修改useradd 参数

```bash
[root@study ~]# usermod [-cdegGlsuLU] username
选项与参数：
-c ：后面接帐号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。
-d ：后面接帐号的主文件夹，即修改 /etc/passwd 的第六栏；
-e ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！
-f ：后面接天数，为 shadow 的第七字段。
-g ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！
-G ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group 啰～
-a ：与 -G 合用，可“增加次要群组的支持”而非“设置”喔！
-l ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！
-s ：后面接 Shell 的实际文件，例如 /bin/bash 或 /bin/csh 等等。
-u ：后面接 UID 数字啦！即 /etc/passwd 第三栏的数据；
-L ：暂时将使用者的密码冻结，让他无法登陆。其实仅改 /etc/shadow 的密码栏。
-U ：将 /etc/shadow 密码栏的 ! 拿掉，解冻啦！
```

```bash
范例一：修改使用者 vbird2 的说明栏，加上“VBird's test”的说明。
[root@study ~]# usermod -c "VBird's test" vbird2
[root@study ~]# grep vbird2 /etc/passwd
vbird2:x:1500:100:VBird's test:/home/vbird2:/bin/bash
范例二：使用者 vbird2 这个帐号在 2015/12/31 失效。
[root@study ~]# usermod -e "2015-12-31" vbird2
[root@study ~]# chage -l vbird2 &#124; grep 'Account expires'
Account expires : Dec 31, 2015
范例三：我们创建 vbird3 这个系统帐号时并没有给予主文件夹，请创建他的主文件夹
[root@study ~]# ll -d ~vbird3
ls: cannot access /home/vbird3: No such file or directory &lt;==确认一下，确实没有主文件夹的存在！
[root@study ~]# cp -a /etc/skel /home/vbird3
[root@study ~]# chown -R vbird3:vbird3 /home/vbird3
[root@study ~]# chmod 700 /home/vbird3
[root@study ~]# ll -a ~vbird3
drwx------. 3 vbird3 vbird3 74 May 4 17:51 . &lt;==使用者主文件夹权限
drwxr-xr-x. 10 root root 4096 Jul 20 22:51 ..
-rw-r--r--. 1 vbird3 vbird3 18 Mar 6 06:06 .bash_logout
-rw-r--r--. 1 vbird3 vbird3 193 Mar 6 06:06 .bash_profile
-rw-r--r--. 1 vbird3 vbird3 231 Mar 6 06:06 .bashrc
drwxr-xr-x. 4 vbird3 vbird3 37 May 4 17:51 .mozilla
# 使用 chown -R 是为了连同主文件夹下面的使用者/群组属性都一起变更的意思；
# 使用 chmod 没有 -R ，是因为我们仅要修改目录的权限而非内部文件的权限！
```

删除用户的命令如下

```bash
[root@study ~]# userdel [-r] username
选项与参数：
-r ：连同使用者的主文件夹也一起删除
范例一：删除 vbird2 ，连同主文件夹一起删除
[root@study ~]# userdel -r vbird2
```

这个指令下达的时候要小心了！通常我们要移除一个帐号的时候，你可以手动的将
/etc/passwd 与 /etc/shadow 里头的该帐号取消即可！一般而言，如果该帐号只是“暂时不启
用”的话，那么将 /etc/shadow 里头帐号失效日期 （第八字段） 设置为 0 就可以让该帐号无法使用，但是所有跟该帐号相关的数据都会留下来！ 使用 userdel 的时机通常是“你真的确定不要让该用户在主机上面使用任何数据了！”

### 9.2.2 使用者功能

id 这个指令则可以查询某人或自己的相关 UID/GID 等等的信息，他的参数也不少，不过，都
不需要记～反正使用 id 就全部都列出啰！ 另外，也回想一下，我们在前一章谈到的循环时，就有用过这个指令喔！

```bash
[root@study ~]# id [username]
范例一：查阅 root 自己的相关 ID 信息！
[root@study ~]# id
uid=0（root） gid=0（root） groups=0（root） context=unconfined_u:unconfined_r:unconfined_t:
s0-s0:c0.c1023
# 上面信息其实是同一行的数据！包括会显示 UID/GID 以及支持的所有群组！
# 至于后面那个 context=... 则是 SELinux 的内容，先不要理会他！
范例二：查阅一下 vbird1 吧～
[root@study ~]# id vbird1
uid=1003（vbird1） gid=1004（vbird1） groups=1004（vbird1）
[root@study ~]# id vbird100
id: vbird100: No such user &lt;== id 这个指令也可以用来判断系统上面有无某帐号！
```

finger 的中文字面意义是：“手指”或者是“指纹”的意思。这个 finger 可以查阅很多使用者相关
的信息喔！ 大部分都是在 /etc/passwd 这个文件里面的信息啦！不过，这个指令有点危险，
所以新的版本中已经默认不安装这个软件！

```bash
[root@study ~]# finger [-s] username
选项与参数：
-s ：仅列出使用者的帐号、全名、终端机代号与登陆时间等等；
-m ：列出与后面接的帐号相同者，而不是利用部分比对 （包括全名部分）
范例一：观察 vbird1 的使用者相关帐号属性
[root@study ~]# finger vbird1
Login: vbird1 Name:
Directory: /home/vbird1 Shell: /bin/bash
Never logged in.
No mail.
No Plan.
```

由于 finger 类似指纹的功能，他会将使用者的相关属性列出来！如上表所示，其实他列出来
的几乎都是 /etc/passwd 文件里面的东西。列出的信息说明如下：

- Login：为使用者帐号，亦即 /etc/passwd 内的第一字段；

- Name：为全名，亦即 /etc/passwd 内的第五字段（或称为注解）；

- Directory：就是主文件夹了；

- Shell：就是使用的 Shell 文件所在；

- Never logged in.：figner 还会调查使用者登陆主机的情况喔！

- No mail.：调查 /var/spool/mail 当中的信箱数据；

- No Plan.：调查 ~vbird1/.plan 文件，并将该文件取出来说明！

我们可以创建一个自己的计划档

```bash
范例二：利用 vbird1 创建自己的计划档
[vbird1@study ~]$ echo "I will study Linux during this year." &gt; ~/.plan
[vbird1@study ~]$ finger vbird1
Login: vbird1 Name:
Directory: /home/vbird1 Shell: /bin/bash
Last login Mon Jul 20 23:06 （CST） on pts/0
No mail.
Plan:
I will study Linux during this year.
范例三：找出目前在系统上面登陆的使用者与登陆时间
[vbird1@study ~]$ finger
Login Name Tty Idle Login Time Office Office Phone Host
dmtsai dmtsai tty2 11d Jul 7 23:07
dmtsai dmtsai pts/0 Jul 20 17:59
```

chfn 有点像是： change finger 的意思！这玩意的使用方法如下：

```bash
[root@study ~]# chfn [-foph] [帐号名]
选项与参数：
-f ：后面接完整的大名；
-o ：您办公室的房间号码；
-p ：办公室的电话号码；
-h ：家里的电话号码！
范例一：vbird1 自己更改一下自己的相关信息！
[vbird1@study ~]$ chfn
Changing finger information for vbird1.
Name []: VBird Tsai test &lt;==输入你想要呈现的全名
Office []: DIC in KSU &lt;==办公室号码
Office Phone []: 06-2727175#356 &lt;==办公室电话
Home Phone []: 06-1234567 &lt;==家里电话号码
Password: &lt;==确认身份，所以输入自己的密码
Finger information changed.
[vbird1@study ~]$ grep vbird1 /etc/passwd
vbird1:x:1003:1004:VBird Tsai test,DIC in KSU,06-2727175#356,06-1234567:/home/vbird1:/bin/bash
# 其实就是改到第五个字段，该字段里面用多个“ , ”分隔就是了！
[vbird1@study ~]$ finger vbird1
Login: vbird1 Name: VBird Tsai test
Directory: /home/vbird1 Shell: /bin/bash
Office: DIC in KSU, 06-2727175#356 Home Phone: 06-1234567
Last login Mon Jul 20 23:12 （CST） on pts/0
No mail.
Plan:
I will study Linux during this year.
# 就是上面特殊字体呈现的那些地方是由 chfn 所修改出来的！
```

chsh就是 change shell 的简写！使用方法就更简单了！

```bash
[vbird1@study ~]$ chsh [-ls]
选项与参数：
-l ：列出目前系统上面可用的 shell ，其实就是 /etc/shells 的内容！
-s ：设置修改自己的 Shell 啰
范例一：用 vbird1 的身份列出系统上所有合法的 shell，并且指定 csh 为自己的 shell
[vbird1@study ~]$ chsh -l
/bin/sh
/bin/bash
/sbin/nologin &lt;==所谓：合法不可登陆的 Shell 就是这玩意！
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh &lt;==这就是 C shell 啦！
# 其实上面的信息就是我们在 [bash](../Text/index.html) 中谈到的 /etc/shells 啦！
[vbird1@study ~]$ chsh -s /bin/csh; grep vbird1 /etc/passwd
Changing shell for vbird1.
Password: &lt;==确认身份，请输入 vbird1 的密码
Shell changed.
vbird1:x:1003:1004:VBird Tsai test,DIC in KSU,06-2727175#356,06-1234567:/home/vbird1:/bin/csh
[vbird1@study ~]$ chsh -s /bin/bash
# 测试完毕后，立刻改回来！
[vbird1@study ~]$ ll $（which chsh）
-rws--x--x. 1 root root 23856 Mar 6 13:59 /bin/chsh
```
